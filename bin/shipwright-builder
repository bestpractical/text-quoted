#!/usr/bin/env perl
use warnings;
use strict;

use File::Spec;
use File::Temp qw/tempdir/;
use File::Copy qw/move copy/;
use File::Find qw/find/;
use Config;
use Getopt::Long;
use Cwd;

my $build_base = getcwd;

my %args;
GetOptions( \%args, 'install-base=s', 'perl=s', 'skip=s', 'skip-test',
    'only-test' );

unlink 'build.log' if -e 'build.log';
open my $log, '>', 'build.log' or die $!;

unless ( $args{'install-base'} ) {
    $args{'install-base'} = tempdir;
    print $log "no default install-base, will set it to $args{'install-base'}\n";
}

if ( grep { $_ eq 'perl' } @$order ) {
    $args{perl} = File::Spec->catfile($args{'install-base'}, 'bin', 'perl');
}
else {
    $args{perl} = $^X;
}

$args{skip} = [ split /,\s*/, $args{skip} || '' ];

{
    no warnings 'uninitialized';
    $ENV{DYLD_LIBRARY_PATH} =
      File::Spec->catfile( $args{'install-base'}, 'lib' ) . ':'
      . $ENV{DYLD_LIBRARY_PATH};
    $ENV{LD_LIBRARY_PATH} =
      File::Spec->catfile( $args{'install-base'}, 'lib' ) . ':'
      . $ENV{LD_LIBRARY_PATH};
    $ENV{PERL5LIB} =
      File::Spec->catfile( $args{'install-base'}, 'lib', 'perl5' ) . ':'
      . $ENV{PERL5LIB};
    $ENV{PATH} =
        File::Spec->catfile( $args{'install-base'}, 'bin' ) . ':'
      . File::Spec->catfile( $args{'install-base'}, 'sbin' ) . ':'
      . $ENV{PATH};
    $ENV{PERL_MM_USE_DEFAULT} = 1;
}

if ( $args{'only-test'} ) {
    test();
}
else {
    mkdir $args{'install-base'} unless -e $args{'install-base'};

    mkdir File::Spec->catfile( $args{'install-base'},       'etc' )
      unless -e File::Spec->catfile( $args{'install-base'}, 'etc' );

    copy(
        File::Spec->catfile( 'etc', 'shipwright-script-wrapper' ),
        File::Spec->catfile(
            $args{'install-base'}, 'etc', 'shipwright-script-wrapper'
        )
    );

    my $order = parse_order( File::Spec->catfile( 'shipwright', 'order.yml' ) );

    for my $dist (@$order) {
        unless ( grep { $dist eq $_ } @{ $args{skip} } ) {
            install($dist);
        }
        chdir $build_base;
    }

    wrap_bin();
    print "install finished, the dists are at $args{'install-base'}\n";
    print $log "install finished, the dists are at $args{'install-base'}\n";
}

sub install {
    my $dir = shift;

    my @cmds;
    {
        open my $fh, '<', File::Spec->catfile( 'scripts', $dir, 'build' )
          or die $!;
        @cmds = <$fh>;
        close $fh;
        chomp @cmds;
        @cmds = map { substitute($_) } @cmds;
    }

    chdir File::Spec->catfile( 'dists', $dir );

    for (@cmds) {
        my ( $type, $cmd );
        next unless /\S/;

        if (/^(\S+):\s*(.*)/) {
            $type = $1;
            $cmd  = $2;
        }
        else {
            $type = '';
            $cmd  = $_;
        }

        if ( $args{'skip-test'} && $type eq 'test' ) {
            print $log "skip build $type part in $dir\n";
            next;
        }

        print $log "build $type part in $dir with cmd: $cmd\n";

        print "we'll run the cmd: $cmd\n";
        if ( system($cmd) ) {
            print $log "build $dir with failure when run $type: $!\n";
            die "build $dir with failure when run $type: $!\n";
        }
    }

    print $log "build $dir with success!\n";
}

sub wrap_bin {
    my $self = shift;

    my %seen;

    my $sub = sub {
        my $file = $_;
        return unless $file and -f $file;
        return if $seen{$File::Find::name}++;
        my $dir = ( File::Spec->splitdir($File::Find::dir) )[-1];
        mkdir File::Spec->catfile( $args{'install-base'}, "$dir-wrapped" )
          unless -d File::Spec->catfile( $args{'install-base'},
            "$dir-wrapped" );
        move( $file =>
              File::Spec->catfile( $args{'install-base'}, "$dir-wrapped" ) )
          or die $!;
        symlink File::Spec->catfile( '..', 'etc',
            'shipwright-script-wrapper' ) => $file
          or die $!;
        chmod 0755, $file;
    };

    my @dirs =
      grep { -d $_ }
      map { File::Spec->catfile( $args{'install-base'}, $_ ) }
      qw/bin sbin libexec/;
    find( $sub, @dirs ) if @dirs;

}

sub substitute {
    my $text = shift;
    return unless $text;

    my $perl         = $args{'perl'};
    my $install_base = $args{'install-base'};
    $text =~ s/%%PERL%%/$perl/g;
    $text =~ s/%%INSTALL_BASE%%/$install_base/g;
    return $text;
}

sub parse_order {
    my $file  = shift;
    my $order = [];
    open my $fh, '<', $file or die $!;
    while (<$fh>) {
        if (/^- (\S+)/) {
            push @$order, $1;
        }
    }
    return $order;
}

sub test {

    my @cmds;
    {
        open my $fh, '<', File::Spec->catfile( 't', 'test' )
          or die $!;
        @cmds = <$fh>;
        close $fh;
        chomp @cmds;
        @cmds = map { substitute($_) } @cmds;
    }

    for (@cmds) {
        my ( $type, $cmd );
        next unless /\S/;

        if (/^(\S+):\s*(.*)/) {
            $type = $1;
            $cmd  = $2;
        }
        else {
            $type = '';
            $cmd  = $_;
        }

        print "run tests $type with cmd: $cmd\n";
        system($cmd) && die "something wrong when execute $cmd: $?";
    }

}

